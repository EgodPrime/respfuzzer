import subprocess
import asyncio
import enum
import tempfile
from typing import List

from mplfuzz.models import API, PosType, APICallExecution
from mplfuzz.utils.config import get_config
from mplfuzz.db.apicall_execution_record_table import create_apicall_execution, update_apical_execution
from openai import AsyncOpenAI


class ExecutionResultType(enum.IntEnum):
    OK = 0
    CALLFAIL = 0b001
    ABNORMAL = 0b010
    TIMEOUT = 0b100


def safe_run(command):
    result_type = ExecutionResultType.OK
    ret_code = 0
    stdout = ""
    stderr = ""
    try:
        # 启动子进程
        proc = subprocess.Popen(
            command,
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
            stdin=subprocess.PIPE,
            text=True,  # 读取为字符串
            shell=False,
            start_new_session=True,
        )

        # 读取输出（捕获所有）
        stdout, stderr = proc.communicate(input="\n" * 24, timeout=10)  # 10秒超时
        ret_code = proc.returncode
        if ret_code != 0:
            result_type = ExecutionResultType.ABNORMAL
    except subprocess.TimeoutExpired:
        result_type = ExecutionResultType.TIMEOUT
        proc.kill()
        stdout, stderr = proc.communicate()
    except Exception as e:
        result_type = ExecutionResultType.CALLFAIL
        stderr = str(e)
    finally:
        result = {
            "result_type": result_type,
            "ret_code": ret_code,
            "stdout": stdout,
            "stderr": stderr,
        }
        return result


def clean_arg_name(arg_name: str) -> str:
    if arg_name.startswith("*"):
        return arg_name.replace("*", "")
    return arg_name


def to_executable_code(api: API, input_dict: dict) -> str:
    api_arg_list = api.args
    api_arg_pos_type_map = {arg.arg_name: arg.pos_type for arg in api_arg_list}
    code = f"""# This is a fuzzing code generated by `mplfuzz`
{f"import {api.api_name.split('.')[0]}" if "." in api.api_name else ""}
"""
    for key, val in input_dict.items():
        code += f"{clean_arg_name(key)} = {val}\n"
    code += f"result = {api.api_name}("
    for key in input_dict.keys():
        pos_type = api_arg_pos_type_map[key]
        if pos_type == PosType.PositionalOnly:
            code += f"{clean_arg_name(key)}, "
        else:
            code += f"{clean_arg_name(key)}={clean_arg_name(key)}, "

    code += f""")\n
print(result)
"""
    return code


def execute_api_call(api: API, input_dict: dict) -> dict:
    args = api.args
    arg_name_list = [arg.arg_name for arg in args]
    for input_arg_name in input_dict.keys():
        if input_arg_name not in arg_name_list:
            return {"result_type": ExecutionResultType.CALLFAIL, "stderr": f"Invalid argument: {input_arg_name}"}
    code = to_executable_code(api, input_dict)
    # print(f"\n{code}\n")
    with tempfile.NamedTemporaryFile(mode="w+", suffix=".py", delete=True) as f:
        f.write(code)
        f.flush()
        command = ["python", f.name]
        result = safe_run(command)
        return result


async def async_safe_run(command: List[str]):
    result_type = ExecutionResultType.OK
    ret_code = 0
    stdout = ""
    stderr = ""
    try:
        proc = await asyncio.create_subprocess_exec(
            *command,
            stdin=asyncio.subprocess.PIPE,
            stdout=asyncio.subprocess.PIPE,
            stderr=asyncio.subprocess.PIPE,
            start_new_session=True,
        )

        try:
            stdout_bytes, stderr_bytes = await asyncio.wait_for(proc.communicate(input=b"\n" * 24), timeout=10)
            stdout = stdout_bytes.decode("utf-8", errors="ignore")
            stderr = stderr_bytes.decode("utf-8", errors="ignore")
            ret_code = proc.returncode
            if ret_code != 0:
                result_type = ExecutionResultType.ABNORMAL
        except asyncio.TimeoutError:
            result_type = ExecutionResultType.TIMEOUT
            proc.kill()
            await proc.wait()
            stdout_bytes, stderr_bytes = await proc.communicate()
            stdout = stdout_bytes.decode("utf-8", errors="ignore")
            stderr = stderr_bytes.decode("utf-8", errors="ignore")
    except Exception as e:
        result_type = ExecutionResultType.CALLFAIL
        stderr = str(e)

    return {
        "result_type": result_type,
        "ret_code": ret_code,
        "stdout": stdout,
        "stderr": stderr,
    }

async def polish_code(ori_code:str) -> str:
    prompt = f"你是一个代码审计员，你会检查下述代码是否缺少适当的的import， 如果是的话你会对代码进行补全，否则你不做任何修改。你仅输出补全后的代码，不要输出```!\n{ori_code}"
    model_config = get_config("model_config").unwrap()
    model_name = model_config.get("model_name")
    openai_client = AsyncOpenAI(
        base_url=model_config.get("base_url"),
        api_key=model_config.get("api_key"),
    )
    response = await openai_client.chat.completions.create(
        model=model_name,
        messages=[
            {"role": "user", "content": prompt},
        ],
        extra_body={"chat_template_kwargs": {"enable_thinking": False}}
    )
    return response.choices[0].message.content


async def async_execute_api_call(api: API, input_dict: dict[str, str]):
    args = api.args
    # arg_name_list = [arg.arg_name for arg in args]
    # for input_arg_name in input_dict.keys():
    #     if input_arg_name not in arg_name_list:
    #         return {"result_type": ExecutionResultType.CALLFAIL, "stderr": f"Invalid argument: {input_arg_name}"}
    code = to_executable_code(api, input_dict)
    # code = await polish_code(code)

    with tempfile.NamedTemporaryFile(mode="w+", suffix=".py", delete=True) as f:
        f.write(code)
        f.flush()
        command = ["python", f.name]
        ae = APICallExecution(
            api_id=api.id,
            library_name=api.library_name,
            api_name=api.api_name,
            code=code,
            result_type=-1,
            ret_code=-1,
            stdout='',
            stderr=''
        )
        create_apicall_execution(ae).unwrap()
        result = await async_safe_run(command)
        ae.result_type = result["result_type"]
        ae.ret_code = result["ret_code"]
        ae.stdout = result["stdout"]
        ae.stderr = result["stderr"]
        update_apical_execution(ae).unwrap()
        return result


"""
# TODO: 变异是否等价于编解码
目前的变异器得到的结果是一个表达式，例如
```
pandas.core.interchange.from_dataframe.from_dataframe(
    df=pandas.DataFrame(
        {"A": [1, 2], "B": [3, 4]}), 
        allow_copy=False
)
```
缺少import（保证调用成功）和对结果的简单使用（增加触发概率）
但如果让大模型检查这个表达式，并进行补全，则会得到
```
import pandas as pd

df = pd.DataFrame({"A": [1, 2], "B": [3, 4]})
interchange_df = df.to_interchange()
print(interchange_df)
```

这个过程是不是很像编码和解码？（需要进一步斟酌）
完整的API源码经过解析+调用生成过程对应了信源
将完整的API调用代码简化成API调用表达式对应了编码过程
变异对应了加噪声的过程
而让大模型重新生成调用代码对应了解码过程

因为编码的过程丢失了参数名、import等信息，所以这个过程还是有损编码

# TODO: 变异的过程可能更像是转换(Transform)?
完整API调用代码->核心API调用表达式->完整API调用代码

# TODO：import部分是否不应该交由大模型来生成？
NO，大模型生成的参数值表达式可能会引用别的库
所以完整的生成过程应该是：
API源码--静态分析-->API参数字典--大模型-->API参数值表达式list--静态代码生成-->API调用代码（可能缺少依赖导入）--大模型-->完整API调用代码
这样应该能在生成API调用环节提高通过率？需要尝试一下


"""


async def async_execute_api_call_expr(api_call_expr: str):
    api_name = api_call_expr.split("(")[0]
    library_name = api_name.split(".")[0]
    code = f"import {library_name}\n{api_call_expr}\n"
    with tempfile.NamedTemporaryFile(mode="w+", suffix=".py", delete=True) as f:
        f.write(code)
        f.flush()
        command = ["python", f.name]
        result = await async_safe_run(command)
        return result


if __name__ == "__main__":
    # 示例调用
    case1 = "import sys; print(1); sys.stdout.flush(); import os; os._exit(0)"
    case2 = "raise Exception('1')"
    case3 = "import time; time.sleep(15)"

    res = safe_run(["python", "-c", case1])  # 模拟正常情况
    print(res)

    res = safe_run(["python", "-c", case2])  # 模拟子进程崩溃
    print(res)

    res = safe_run(["python", "-c", case3])  # 模拟长时间运行
    print(res)

    with tempfile.NamedTemporaryFile(mode="w+", suffix=".py", delete_on_close=True) as f:
        f.write("raise Exception('1')")
        f.flush()
        command = ["python", f.name]
        print(command)
        result = safe_run(command)
        print(result)
