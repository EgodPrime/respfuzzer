import json
import subprocess
import os
import sys
import signal
import asyncio
import enum
import tempfile
from typing import List

from mplfuzz.models import API, PosType


class ExecutionResultType(enum.IntEnum):
    OK = 0
    CALLFAIL = 0b001
    ABNORMAL = 0b010
    TIMEOUT = 0b100

def safe_run(command):
    result_type = ExecutionResultType.OK
    ret_code = 0
    stdout = ""
    stderr = ""
    try:
        # 启动子进程
        proc = subprocess.Popen(
            command,
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
            stdin=subprocess.PIPE,
            text=True,  # 读取为字符串
            shell=False,
            start_new_session=True,
        )

        # 读取输出（捕获所有）
        stdout, stderr = proc.communicate(input="\n"*24,timeout=10)  # 10秒超时
        ret_code = proc.returncode
        if ret_code != 0:
            result_type = ExecutionResultType.ABNORMAL
    except subprocess.TimeoutExpired:
        result_type = ExecutionResultType.TIMEOUT
        proc.kill()
        stdout, stderr = proc.communicate()
    except Exception as e:
        result_type = ExecutionResultType.CALLFAIL
        stderr = str(e)
    finally:
        result = {
            "result_type": result_type,
            "ret_code": ret_code,
            "stdout": stdout,
            "stderr": stderr,
        }
        return result

def clean_arg_name(arg_name: str) -> str:
    if arg_name.startswith("*"):
        return arg_name.replace("*", "")
    return arg_name

def to_executable_code(api: API, input_dict: dict) -> str:
    api_arg_list = api.args
    api_arg_pos_type_map = {arg.name: arg.pos_type for arg in api_arg_list}
    code = f"""# This is a fuzzing code generated by `mplfuzz`
{f"import {api.name.split('.')[0]}" if "." in api.name else ""}
"""
    
    for key,val in input_dict.items():
        code += f"{clean_arg_name(key)} = {val}\n"
    code += f"result = {api.name}("
    for key in input_dict.keys():
        pos_type = api_arg_pos_type_map[key]
        if pos_type == PosType.PositionalOnly:
            code += f"{clean_arg_name(key)}, "
        else:
            code += f"{clean_arg_name(key)}={clean_arg_name(key)}, "
    
    code += f""")\n
print(result)
"""
    return code

def execute_api_call(api: API, input_dict: dict) -> dict:
    args = api.args
    arg_name_list = [arg.name for arg in args]
    for input_arg_name in input_dict.keys():
        if input_arg_name not in arg_name_list:
            return {"result_type": ExecutionResultType.CALLFAIL,
                     "stderr": f"Invalid argument: {input_arg_name}"
                    }
    code = to_executable_code(api, input_dict)
    # print(f"\n{code}\n")
    with tempfile.NamedTemporaryFile(mode='w+', suffix=".py", delete=True) as f:
        f.write(code)
        f.flush()
        command = ["python", f.name]
        result = safe_run(command)
        return result

async def async_safe_run(command: List[str]):
    result_type = ExecutionResultType.OK
    ret_code = 0
    stdout = ""
    stderr = ""
    try:
        proc = await asyncio.create_subprocess_exec(
            *command,
            stdin=asyncio.subprocess.PIPE,
            stdout=asyncio.subprocess.PIPE,
            stderr=asyncio.subprocess.PIPE,
            start_new_session=True,
        )

        try:
            stdout_bytes, stderr_bytes = await asyncio.wait_for(
                proc.communicate(input=b"\n" * 24),
                timeout=10
            )
            stdout = stdout_bytes.decode("utf-8", errors="ignore")
            stderr = stderr_bytes.decode("utf-8", errors="ignore")
            ret_code = proc.returncode
            if ret_code != 0:
                result_type = ExecutionResultType.ABNORMAL
        except asyncio.TimeoutError:
            result_type = ExecutionResultType.TIMEOUT
            proc.kill()
            await proc.wait()
            stdout_bytes, stderr_bytes = await proc.communicate()
            stdout = stdout_bytes.decode("utf-8", errors="ignore")
            stderr = stderr_bytes.decode("utf-8", errors="ignore")
    except Exception as e:
        result_type = ExecutionResultType.CALLFAIL
        stderr = str(e)

    return {
        "result_type": result_type,
        "ret_code": ret_code,
        "stdout": stdout,
        "stderr": stderr,
    }

async def async_execute_api_call(api: API, input_dict: dict[str, str]):
    args = api.args
    arg_name_list = [arg.name for arg in args]
    for input_arg_name in input_dict.keys():
        if input_arg_name not in arg_name_list:
            return {"result_type": ExecutionResultType.CALLFAIL,
                     "stderr": f"Invalid argument: {input_arg_name}"
                    }
    code = to_executable_code(api, input_dict)
    # print(f"\n{code}\n")
    with tempfile.NamedTemporaryFile(mode='w+', suffix=".py", delete=True) as f:
        f.write(code)
        f.flush()
        command = ["python", f.name]
        result = await async_safe_run(command)
        return result
    
if __name__ == "__main__":

    # 示例调用
    case1 = "import sys; print(1); sys.stdout.flush(); import os; os._exit(0)"
    case2 = "raise Exception('1')"
    case3 = "import time; time.sleep(15)"

    res = safe_run(["python", "-c", case1]) # 模拟正常情况 
    print(res)

    res = safe_run(["python", "-c", case2]) # 模拟子进程崩溃
    print(res)

    res = safe_run(["python", "-c", case3]) # 模拟长时间运行
    print(res)


    with tempfile.NamedTemporaryFile(mode='w+', suffix=".py", delete_on_close=True) as f:
        f.write("raise Exception('1')")
        f.flush()
        command = ["python", f.name]
        print(command)
        result = safe_run(command)
        print(result)